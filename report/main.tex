\documentclass{report}

\usepackage{graphicx}
\usepackage{lipsum}  % This package is used for creating dummy text.
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath}

\title{Parallel Huffman}
\author{Giulio Piva}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\chapter{Problem statement}
The huffman algorithm is a lossless compression algorithm that uses a variable length code table
for encoding a source symbol. The code table is derived from the probability of occurrence for each
possible value of the source symbol. The most frequent symbol is encoded with the shortest code
and the least frequent symbol is encoded with the longest code.
The pseudo code for the huffman algorithm is shown in Algorithm 1

\begin{algorithm}
\caption{Huffman code}
\begin{algorithmic}[1]
\Procedure{huffman\_code}{}
\State $\textit{sequence} \gets \text{read\_input(file)}$
\State $\textit{frequency\_map} \gets \text{compute\_frequency(sequence)}$
\State $\textit{huffman\_tree} \gets \text{build\_huffman\_tree(frequency\_map)}$
% \State $\texit{codes\_table} \gets \text{build\_codes\_table(huffman\_tree)}$
\State $\textit{encoded\_sequence} \gets \text{encode(sequence, code\_table)}$
\State $ \textit{return encoded\_sequence}$
\EndProcedure
\end{algorithmic}
\end{algorithm}

The first step of the algorithm is to compute the distribution of the characters in the input sequence,
which is done by counting the frequency of each character. This function has a complexity of $O(n)$,
where $n$ is the length of the input sequence.

\begin{algorithm}
\caption{Frequency counting}
\begin{algorithmic}[1]
\Procedure{compute\_frequency}{sequence}
\State $\textit{frequency\_map} \gets \text{empty map}$
\For{$\text{char} \gets \text{sequence}$}
\State $\textit{frequency\_map[char]++}$
\EndFor
\State $ \textit{return frequency\_map}$
\EndProcedure
\end{algorithmic}
\end{algorithm}
After computing the distribution of the characters in input sequence,
the subsequent step is to build the Huffman tree.
This process is supported by a priority queue to provide
efficient access to the nodes with the lowest frequency.
\begin{algorithm}
\caption{Huffman tree generation}
\begin{algorithmic}[1]
\Procedure{build\_huffman\_tree}{frequency\_map}
\State queue $\gets$ empty priority queue
\For{$\text{char} \gets \text{frequency\_map}$}
\State $\textit{node} \gets \text{node(char, frequency\_map[char], nil, nil)}$
\State $\text{queue.push(node)}$
\EndFor

\While{$\text{queue.size()} > 1$}
\State $\textit{l} \gets \text{queue.pop()}$
\State $\textit{r} \gets \text{queue.pop()}$
\State $\textit{node} \gets node(nil, l.freq + r.freq, l, r)$
\State $\text{queue.push(node)}$
\EndWhile

\State $ \textit{return queue.pop()}$

\EndProcedure
\end{algorithmic}
\end{algorithm}
The time complexity of this algorithm is $O(m \log m)$,
where $m$ is the number of distinct characters in the input sequence.
In our case, since we are dealing with ASCII characters only,
m is equal to 256 and therefore the complexity is constant.
Then, the Huffman tree is traversed to generate the codes for each character
and save them in a map in order to avoid trasversing the tree for
every character in the input sequence.
\begin{algorithm}
\caption{Codes table generation}
\begin{algorithmic}[1]
\Procedure{build\_codes\_table}{root}
\State $\textit{codes\_table} \gets \text{empty map}$
\State $\textit{queue} \gets \text{empty queue}$
\State $\text{queue.push(root)}$
\While{$\text{queue.size()} > 0$}
\State $\textit{node} \gets \text{queue.pop()}$
\If{$\text{node.left} \neq \text{nil}$}
\State $\text{node.left.code} \gets \text{node.code + 0}$
\State $\text{queue.push(node.left)}$
\EndIf
\If{$\text{node.right} \neq \text{nil}$}
\State $\text{node.right.code} \gets \text{node.code + 1}$
\State $\text{queue.push(node.right)}$
\EndIf
\If{$\text{node.char} \neq \text{nil}$}
\State $\textit{codes\_table[node.char]} \gets \text{node.code}$
\EndIf
\EndWhile
\State $ \textit{return codes\_table}$
\EndProcedure
\end{algorithmic}
\end{algorithm}

Finally, the input sequence is scanned again and for each character the corresponding
code is appended to the encoded sequence.

\begin{algorithm}
\caption{Encoding}
\begin{algorithmic}[1]
\Procedure{encode}{sequence, code\_table}

\State $\textit{encoded\_sequence} \gets \text{empty vector of bools}$
\For{$\text{char} \gets \text{sequence}$}
\State $\textit{encoded\_sequence.append(code\_table[char])}$
\EndFor
\State $ \textit{return encoded\_sequence}$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\chapter{Implementation}
This project is implemented as a template design pattern. The main class is the
the \textbf{huffman\_base} class that defines the outline of the algorithm.
This base class defines the functions which are executed sequentially, whereas
the parallel functions are defined as pure virtual functions.
It also includes boilerplate code for reading and writing files,
avoiding therefore code duplication.
For every different version of the algorithm, a new class has been created.
Thus I crafted the \textbf{huffman\_sequential}, \textbf{huffman\_thread} and
\textbf{huffman\_ff} classes.

\section*{Base class}
\subsection*{Frequency counting method}
The signature of the frequency counting method is the following:
\begin{verbatim}
virtual unordered_map<char, int> count_frequency(string) = 0;
\end{verbatim}
Computing the frequencies of character in a map is the optimal choice
both in a sequential and a parallel setting.

\subsection*{Encoding method}

\begin{verbatim}
encoded_t *huffman_thread::encode_string(string sequence, code_table) = 0;
\end{verbatim}
where \textbf{encoded\_t} is a typedef for the following type:
\begin{verbatim}
typedef std::vector<std::vector<std::vector<bool>*>*> encoded_t;
\end{verbatim}

First, the codes produced from the Huffman Tree are stored as a vector of bools to exploit their
efficient space usage. Then the encoded chunks are represented as a vector of pointers to
these vector of bools (the codes). This is done to avoid copying the codes when storing them
in the encoded sequence and ensuring high-speed processing.
This kind of data structure fits well with the parallel version of the algorithm.
It also fits well with the sequential version, as it will just produce a single
large chunk which represents the whole encoded sequence.

\section{Sequential version}

\section{Thread version}
This version uses threads from the C++ standard library.

\section{FastFlow version}

\chapter{Benchmark}

\chapter{Conclusion}

\end{document}